import com.vp.plugin.model.factory.IModelElementFactory
import com.vp.plugin.diagram.IDiagramTypeConstants

def Microservices = ["Frontend", "Payment", "Cart" 	]	//List of microservices on which the refactoring solution will be applied

def SecuritySmells = ["Insufficient Access Control"]	//List of (detected) security smells

def projManager = appManager.getProjectManager()		//Open the project
def proj = projManager.getProject()

def model = proj.toAllLevelModelElementArray("Model")	//Select the model 
def MODEL = model[0]

def diagramManager = appManager.getDiagramManager()

def Diag = diagramManager.getOpenedDiagrams()

//--------------------------------------------------------------------------------------------------------------------------------//
//Take the system model diagram
def Msm = []
Diag.each{diag -> 														
	if (diag.getName() == "Micro Services Model")
		Msm.add(diag)
}
def MSM = Msm[0]
//Take the elements (Microservices) from the system model diagram and save them in an array
def msmel = MSM.toDiagramElementArray()

def msmod = msmel.collect { el ->										
    		return el.getMetaModelElement()
}
def microservices = []//Microservices 

msmod.each{ el ->
	if (el.hasStereotype("Microservice (I)") || el.hasStereotype("Microservice (N)") || el.hasStereotype("Microservice (C)"))
		microservices.add(el)
}
//--------------------------------------------------------------------------------------------------------------------------------//
//Take the security smells knowledge model diagram
def Sskm = []
Diag.each{ diag ->  													
	if (diag.getName() == "Security Smells Model")
		Sskm.add(diag)
}
def SSKM =Sskm[0]
def ss = SSKM.toDiagramElementArray() 
//Take the elements from the system model diagram and save them in an array
def ssmod = ss.collect { el ->
    return el.getMetaModelElement() 
}		
// Take all the associations of the diagram and save them into an array
def SSassociation =[]
for (i=0; i<ssmod.size(); i++){
	if (ssmod[i].getModelType() == "Association"){
		SSassociation.add(ssmod[i])
	}
}
//--------------------------------------------------------------------------------------------------------------------------------//
//Take SIG diagram
def SIG = diagramManager.getActiveDiagram()

def elements = SIG.toDiagramElementArray() 

def mod = elements.collect { el ->
    return el.getMetaModelElement() 
}		

def SGList = []	//List of elements as IModelElements (only SG classes)
def SGListName = []	//List of elements names (only SG classes)
def relFrom = []	//Adjancency List of associations between elements: each entry is the array of the starting elements of the associations
// starting from the correspondent element (then we will take the element in the opposit apex)

//Take the elements (Microservice.SoftGoal) and save them in an array
mod.each{ el ->
	if (el.hasStereotype("Functional SoftGoal") || el.hasStereotype("Security SoftGoal")){
		SGListName.add(el.getName())
		SGList.add(el)
		relFrom.add(el.toToRelationshipArray())
		} //Construct the previous vectors
	}

def asstype =[]
for (i=0; i<mod.size(); i++){
	if (mod[i].getModelType() == "Generalization")
		asstype.add(mod[i])
	}

//--------------------------------------------------------------------------------------------------------------------------------//
//function to create a new node of the subgraph
def createNode(i, SGList, SGListName, REF, newPackage, NewSG, NewSGShape, diagramManager){
	el = IModelElementFactory.instance().createClass()	//Create the class object
	el.setName(SGListName[i])//Set the name from the previous list
	at = IModelElementFactory.instance().createAttribute()	//Create an attribute with the name of the softgoal
	at.setName(SGList[i].toChildArray()[0].getName())		
	el.addChild(at)
	at1 = IModelElementFactory.instance().createAttribute()	//Create another attribute with the name of the Main SG it belongs (or Main)
	at1.setName(SGList[i].toChildArray()[1].getName())								
	el.addChild(at1)
	el.addStereotype(SGList[i].toStereotypeModelArray()[0].getName())	//Add the correct stereotype
	NewSG.add(el)
	newPackage.addChild(el)		//Add the just created class to the correct package
	def e1 = diagramManager.createDiagramElement(REF, el);	//Add the class to the diagram
	NewSGShape.add(e1)			//Add the class to the Array of the elements (classes) of the current diagram
	return NewSG.size()-1		//Return the position of this class in the array contain all the classes of the new diagra,
}
//--------------------------------------------------------------------------------------------------------------------------------//
//function to create a new arch (of type generalization) in the subgraph
def createGen(i, j, SGList, REF, newPackage, NewSG, NewSGShape, diagramManager, ster){
	def ass = IModelElementFactory.instance().createGeneralization()	//Create the association
	newPackage.addChild(ass)
	ass.setFrom(NewSG[j])
	ass.setTo(NewSG[i])
	ass.addStereotype(ster)
	def ppp= diagramManager.createConnector(REF, ass, NewSGShape[j], NewSGShape[i], null)
	ppp.setRequestResetCaption(true);
	
}
//--------------------------------------------------------------------------------------------------------------------------------//
//function to create a new arch (of type association) in the subgraph
def createAss(i, j, REF, newPackage, NewSG, NewSGShape, diagramManager,old, ster, superclass, vetass){
	def ass = IModelElementFactory.instance().createAssociation()	//Create the association
	newPackage.addChild(ass)
	ass.setFrom(NewSG[j])
	ass.setTo(NewSG[i])
	if (superclass == true || old == "F" || old == "S"){	//It check if the influence is direct or indirect
		if (ster == "f+" || ster == "f++" || ster == "F+")
			ster = "F+"
		if (ster == "f-" || ster == "f--" || ster == "F-")
			ster = "F-"
		if (ster == "s+" || ster == "s++" || ster == "S+")
			ster = "S+"
		if (ster == "s-" || ster == "s--" || ster == "S-")
			ster = "S-"
	}
	ass.addStereotype(ster)
	vetass.add(ass)
	def ppp= diagramManager.createConnector(REF, ass, NewSGShape[j], NewSGShape[i], null)
	ppp.setRequestResetCaption(true);
}

//--------------------------------------------------------------------------------------------------------------------------------//
//function which returns the position of a microservice in the microservice array given its name
def findMS(micro, name){
	for (i=0; i<micro.size(); i++){
		if (micro[i].getName()==name)
			return i
	}
}

//--------------------------------------------------------------------------------------------------------------------------------//
//funcion to check the presence of an element in an array given its name
def presence(els, name){
	for (i=0; i<els.size(); i++){
		if (els[i].getName() == name)
			return true
	}
	return false
}

//--------------------------------------------------------------------------------------------------------------------------------//
//function to generate to find and generate the subgraph following the relation between MS and between SG doing a DFS on the SIG diagram
def findSG(i, relFrom, SGList, SGListName, REF, newPackage, NewSG, NewSGShape, diagramManager, ssmod, asstype, ster, superclass, vetass){
	def vis=[]		//visited nodes
	def index =0	//index of the current node in the list of SIG classes
	def stack =[SGList[i]]		//stack initialized with the radix we give as input
	def newindex = createNode(i, SGList, SGListName, REF, newPackage, NewSG, NewSGShape, diagramManager)	//add the raxid to the new diagram
	def radixindex = newindex
	while (stack.size()>0) {	//until the stack is empty
		def node = stack.pop()
		if (SGListName[i] != node.getName()){	//if the popped node is not the radix of the graph
			for (a=0; a< SGListName.size(); a++){	//find the index of the popped node in the SIG
				if (SGListName[a] == node.getName()){
					index = a
					break
				}
			}
			if (vis.contains(SGList[index]) == false){	//if the popped node wasn't already visited
				for (a=0; a<NewSG.size(); a++){	//find the index of the popped node in this new diagram
					if (NewSG[a].getName() == node.getName()){
						newindex = a
						break
					}
				}
				for (d=0; d<relFrom[index].size(); d++){	//for each child of the poopped node
					def childindex=0
					for (a=0; a <SGListName.size(); a++){	//find its index in the SIG
						if (SGListName[a] == relFrom[index][d].getFrom().getName()){
							childindex = a
							break
						}
					}
					//if the child is not present in the new diagram yet
					if (stack.contains(SGList[childindex])== false && vis.contains(SGList[childindex])== false && presence(NewSG, SGList[childindex].getName()) == false){
						newchild = createNode(childindex, SGList, SGListName, REF, newPackage, NewSG, NewSGShape, diagramManager)	//create the node in the new diagram
						def old = ""
						for (k=0; k<asstype.size(); k++){	//find the stereotype of the association in the SIG
							if (asstype[k].getFrom() == SGList[childindex] && asstype[k].getTo() == SGList[index]){
								old = asstype[k].toStereotypeModelArray()[0].getName()
							break
							}	
						}
						//create the association and add it to the new diagram
						createAss(newindex, newchild, REF, newPackage, NewSG, NewSGShape, diagramManager, old, ster, superclass, vetass)
						//add the just created node to the stack
						stack.add(relFrom[index][d].getFrom())
					}
					else{	//if the node is already in the diagram
						for (a=0; a <NewSG.size(); a++){	//find its index in the list of elements of the new diagram
							if (NewSG[a].getName() == relFrom[index][d].getFrom().getName()){
								newchild = a
								break
								}
							}
						pres = false
						for (k=0; k<vetass.size(); k++){	//check if the association with its father already exist
							if (vetass[k].getFrom().getName() == SGList[childindex].getName() && vetass[k].getTo().getName() == SGList[index].getName()){
								pres=true
								break
							}
						}
						if (pres == false){	//if the association doesn't exist
							def old = ""
							for (k=0; k<asstype.size(); k++){	//find its stereotype in SIG
								if (asstype[k].getFrom() == SGList[childindex] && asstype[k].getTo() == SGList[index]){
									old = asstype[k].toStereotypeModelArray()[0].getName()
								break
								}	
							}
							//create the association
							createAss(newindex, newchild, REF, newPackage, NewSG, NewSGShape, diagramManager, old, ster, superclass, vetass)
							//add the just created node to the stack
							stack.add(relFrom[index][d].getFrom())
						}
					}	
				}
			}	
		}
		else{//the node is the radix of the new diagram
			for (d=0; d<relFrom[i].size(); d++){	//for each "child" of the node
				def childindex=0
				for (a=0; a <SGListName.size(); a++){	//find the index in the list of SIG element
					if (SGListName[a] == relFrom[i][d].getFrom().getName()){
						childindex = a
						break
					}
				}
				if (presence(NewSG, SGList[childindex].getName())==false){	//if the node isn't already in the new diagram
					newchild = createNode(childindex, SGList, SGListName, REF, newPackage, NewSG, NewSGShape, diagramManager)	//create the node
					def old = ""
					for (k=0; k<asstype.size(); k++){		//find the stereotype of the arrow which connect from the radix
						if (asstype[k].getFrom() == SGList[childindex] && asstype[k].getTo() == SGList[i]){
							old = asstype[k].toStereotypeModelArray()[0].getName()
						break
						}	
					}
					//create the association with this new node and add in the new diagram
					createAss(newindex, newchild, REF, newPackage, NewSG, NewSGShape, diagramManager, old, ster, superclass, vetass)
					stack.add(relFrom[i][d].getFrom())		//add the new class to the stack
				}
				else{//if the node is altready in the diagram
					for (a=0; a <NewSG.size(); a++){	//find its index in the array of the elments of the new diagram
						if (NewSG[a].getName() == relFrom[i][d].getFrom().getName()){
							newchild = a
							break
							}
						}
					def pres = false
					for (k=0; k<vetass.size(); k++){	//find if the node is aready connected in the new diagram
						if (vetass[k].getFrom().getName() == SGList[childindex].getName() && vetass[k].getTo().getName() == SGList[i].getName()){
							pres=true
							break
						}
					}
					if (pres == false){ //if this association doesn't exist
						def old = ""
						for (k=0; k<asstype.size(); k++){	//find the stereotype of this association in the SIG
							if (asstype[k].getFrom() == SGList[childindex] && asstype[k].getTo() == SGList[i]){
								old = asstype[k].toStereotypeModelArray()[0].getName()
							break
							}	
						}
						//create the association
						createAss(newindex, newchild, REF, newPackage, NewSG, NewSGShape, diagramManager, old, ster, superclass, vetass)
						stack.add(relFrom[i][d].getFrom())	//add the new node to the stack
					}
				}
			}		
		}
		vis.add(node)	//add the popped node to the list of visited ones
	}

}

//--------------------------------------------------------------------------------------------------------------------------------//
//function to find and generate subgraphs from SG not present in the refactored MS but in one of MSs depending on it
def findIndirect(micros, SGList, SolEl, SolElShape, SOL, relFrom, SGListName, solPackage, diagramManager, ssmod, asstype, SGsol, vetass){
	for (j=0; j< SGList.size(); j++){
		for (k=0; k< micros.size(); k++){
			if (SGListName[j].contains(micros[k].getName())){
				if (presence(SolEl, SGList[j].getName()) == false){
					prop = SGList[j].toChildArray()
					if (prop[1] == "Main"){		//if the SG of the node is a Main one
						if (SGsol[1] == prop[0].getName())	//check if the main one of the one affected by the refactoring is the same
							findSG(j, relFrom, SGList, SGListName, SOL, solPackage, SolEl, SolElShape, diagramManager, ssmod, asstype, SGsol[3], true, vetass)
					}
					else{		
						if (SGsol[1] == prop[1].getName()){	//check if the main one of the one affected by the refactoring is the same
							if (prop[0].getName() == SGsol[2])  //check if the SGs are the same
								findSG(j, relFrom, SGList, SGListName, SOL, solPackage, SolEl, SolElShape, diagramManager, ssmod, asstype, SGsol[3], false, vetass)
							else{
								if (prop[1].getName() == SGsol[2])	//check if the softgoal of the refactoring is a main one
									findSG(j, relFrom, SGList, SGListName, SOL, solPackage, SolEl, SolElShape, diagramManager, ssmod, asstype, SGsol[3], true, vetass)
							}
						} 
					}
				}
			}
		}
	}
}

//--------------------------------------------------------------------------------------------------------------------------------//
// function to create the subgraph of the SIG with the a specific class as radix (and generalizations as arrows) using a DFS visit of SIG
//it is called to construct the diagram related to each MS (with radix all its SGs
def findSubGraph(i, relFrom, SGList, SGListName, REF, newPackage, NewSG, NewSGShape, diagramManager, ssmod, asstype){
	def vis=[]	//list of visited nodes
	def index =0
	def stack =[SGList[i]]	//stack initialized with the given radix
	def newindex = createNode(i, SGList, SGListName, REF, newPackage, NewSG, NewSGShape, diagramManager)	//create and add the radix node to the new diagram
	def radixindex = newindex
	while (stack.size()>0) {	//while the stack isn't empty
		def node = stack.pop()	
		if (SGListName[i] != node.getName()){	//if the node popped is not the radix
			for (a=0; a< SGListName.size(); a++){	//find the index of the pooped node in the array of SIG elements
				if (SGListName[a] == node.getName()){
					index = a
					break
				}
			}
			if (vis.contains(SGList[index]) == false){	//if the popped nde wasn't already seen
				for (a=0; a<NewSG.size(); a++){		//find its index in the new diagram array of elements
					if (NewSG[a].getName() == node.getName()){
						newindex = a
						break
					}
				}
				for (d=0; d<relFrom[index].size(); d++){	//for each child
					def childindex=0
					for (a=0; a <SGListName.size(); a++){	//find its index in the SIG array of elements
						if (SGListName[a] == relFrom[index][d].getFrom().getName()){
							childindex = a
							break
						}
					}
					if (stack.contains(SGList[childindex])== false && vis.contains(SGList[childindex])== false){	//if the element is not already in the diagram
						newchild=createNode(childindex, SGList, SGListName, REF, newPackage, NewSG, NewSGShape, diagramManager)	//create the node and add to the new diagram
						stack.add(relFrom[index][d].getFrom())	//add the just created node to the stack
					}
					else{	//if the child is already in the diagram
						for (a=0; a <NewSG.size(); a++){	//find its index in the array of element of the new diagram
						if (NewSG[a].getName() == relFrom[index][d].getFrom().getName()){
							newchild = a
							break
							}
						}
					}
					def ster = ""
					for (k=0; k<asstype.size(); k++){	//find the sterotype of the arrow with its father in the SIG
						if (asstype[k].getFrom() == SGList[ childindex] && asstype[k].getTo() == SGList[index]){
							ster = asstype[k].toStereotypeModelArray()[0].getName()
						break
						}	
					}
					//create the generalization in the new diagram
					createGen(newindex, newchild, SGList, REF, newPackage, NewSG, NewSGShape, diagramManager, ster)
					}
			}	
		}
		else{	//if the popped node is the radix
			for (d=0; d<relFrom[i].size(); d++){	//for each child
				def childindex=0
				for (a=0; a <SGListName.size(); a++){	//find its index in the SIG array of elements
					if (SGListName[a] == relFrom[i][d].getFrom().getName()){
						childindex = a
						break
					}
				}
				//create the node in the new diagram
				newchild = createNode(childindex, SGList, SGListName, REF, newPackage, NewSG, NewSGShape, diagramManager)
				def ster = ""
				for (k=0; k<asstype.size(); k++){	//find the stereotype of the arrow with the father in the SIG
					if (asstype[k].getFrom() == SGList[ childindex] && asstype[k].getTo() == SGList[i]){
						ster = asstype[k].toStereotypeModelArray()[0].getName()
					break
					}	
				}
				//create the generalization in the new diagram
				createGen(newindex, newchild, SGList, REF, newPackage, NewSG, NewSGShape, diagramManager, ster)
				stack.add(relFrom[i][d].getFrom())	//add the child node to the stack
			}		
		}
		vis.add(node)	//add the popped node to the list of visited ones
	}
}

//--------------------------------------------------------------------------------------------------------------------------------//
//DFS visit to (Microservice System Model) diagram starting from a given node
def DFS(i, nodes){	//
	def vis=[]
	def stack = [nodes[i]]
	def control = true
	while (stack.size() >0){
		node = stack.pop()
		childs = node.toFromRelationshipEndArray()
		for (i=0; i<childs.size(); i++){
			child = childs[i].getOppositeEnd().getModelElement()
			if (vis.contains(child) == false && stack.contains(child)==false)
				stack.add(child)
		}
		if (control == true)
			control= false
		else
			vis.add(node)
	}
	return vis	//return the list of visited nodes
}

//--------------------------------------------------------------------------------------------------------------------------------//
//function to generate the sudiagram of a particular refactoring solution applied to specific microservices
def fun(micros, SGsol, radix, relFrom, SGList, SGListName, SOL, SolEl, SolElShape, solPackage, diagramManager, ssmod, asstype, vetass){
	for (t=0; t<SGsol.size(); t++){	//foreach SGs affected by the solution
		for (s=0; s<radix.size(); s++){	//foreach radix of the diagram (SGs of the MS to be refactored)
			prop = SGList[radix[s]].toChildArray()	//take the SG of the radix (and its main class)
			if (prop[1] == "Main"){	//if it is a main SG
				if (SGsol[t][1] == prop[0].getName()){	//check if the refactoring affect a SG with the same main SG
					//generate the subgraph in the new diagram
					findSG(radix[s], relFrom, SGList, SGListName, SOL, solPackage, SolEl, SolElShape, diagramManager, ssmod, asstype, SGsol[t][3], true, vetass)
					break
				}
				else	//find if this SG affects other MSs dependent from the one to be refactored
					findIndirect(micros, SGList, SolEl, SolElShape, SOL, relFrom, SGListName, solPackage, diagramManager, ssmod, asstype, SGsol[t], vetass)
			}
			else{
				if (SGsol[t][1] == prop[1].getName()){	//check if the refactoring SG and the radix SG share the main SG
					if (prop[0].getName() == SGsol[t][2]){  //if they are exactly the same
						//generate the subgraph in the new diagram
						findSG(radix[s], relFrom, SGList, SGListName, SOL, solPackage, SolEl, SolElShape, diagramManager, ssmod, asstype, SGsol[t][3], false, vetass)
						break
						}
					else{
						if (SGsol[t][2] == prop[1].getName()){	//if the refactoring one is a Main SG
							//generate the subgraph in the new diagram
							findSG(radix[s], relFrom, SGList, SGListName, SOL, solPackage, SolEl, SolElShape, diagramManager, ssmod, asstype, SGsol[t][3], true, vetass)
							break
						}
						else	//find if this SG affects other MSs dependent from the one to be refactored
							findIndirect(micros, SGList, SolEl, SolElShape, SOL, relFrom, SGListName, solPackage, diagramManager, ssmod, asstype, SGsol[t], vetass)
					}
				}
				else	//find if this SG affects other MSs dependent from the one to be refactored
					findIndirect(micros, SGList, SolEl, SolElShape, SOL, relFrom, SGListName, solPackage, diagramManager, ssmod, asstype, SGsol[t], vetass)
			}
		}
	}	
}

//--------------------------------------------------------------------------------------------------------------------------------//
//function to add the refactoring solution node to the refactoring subgraph and connect it to each radix of each connected component
def createSolNode(sol, micro, SGsol, SolEl, SOL, SolElShape, solPackage, diagramManager, vetass){
	def rad=[]		//find radices of the diagram
	def indices =[]	//indices of the radices in the diagram elements array
	for (i2=0; i2<SolEl.size(); i2++){	//construct the previous arrays
		if (SolEl[i2].toFromRelationshipEndArray().size()<=0){
			rad.add(SolEl[i2])
			indices.add(i2)
		}
	}
	el = IModelElementFactory.instance().createClass()	//Create the class object (refactoring solution node)
	el.setName(sol + " to " + micro) //Set the name as the name as a composition of the refactoring solution name and the microservice one
	el.addStereotype("Refactoring Solution")	//add the correct stereotype
	SolEl.add(el)							//add the el to the diagram array of el
	solPackage.addChild(el)					//add the el to the correct package
	def e1 = diagramManager.createDiagramElement(SOL, el);	//add the el to the diagram
	SolElShape.add(e1)
	index = SolEl.size()-1	//take its position in the elements array
	for (k1=0; k1< rad.size(); k1++){	//for each radix
		prop=rad[k1].toChildArray()	//take its SG and its Main SG
		for (k2=0; k2<SGsol.size(); k2++){	//for each SG affected by the solution
			if (prop[1].getName() == "Main"){	//if the radix SG is a Main one
				if (SGsol[k2][1] == prop[0].getName()){	//if the SG of the solution has the same Main SG
					//create the association between the radix and the refactoring solution node
					createAss(index, indices[k1], SOL, solPackage, SolEl, SolElShape, diagramManager, "", SGsol[k2][3], true, vetass)
					break
				}
			}
			else{
				if (SGsol[k2][1] == prop[1].getName()){	//if the two SGs share the same Main SG
					if (prop[0].getName() == SGsol[k2][2]){  //if they are actually the same SG
						if (rad[k1].getName().contains(micro)){	//if the radix is an original one (a SG of the refactored MS)
							//create the association between the radix and the refactoring solution node
							createAss(index, indices[k1], SOL, solPackage, SolEl, SolElShape, diagramManager, "", SGsol[k2][3], false, vetass)
							break
						}
						else{
							//create the association between the radix and the refactoring solution node
							createAss(index, indices[k1], SOL, solPackage, SolEl, SolElShape, diagramManager, "", SGsol[k2][3], true, vetass)
							break
						}	
					}
					else{
						if (SGsol[k2][2] == prop[1].getName()){	//If the solution SG is a Main one
							//create the association between the radix and the refactoring solution node
							createAss(index, indices[k1], SOL, solPackage, SolEl, SolElShape, diagramManager, "", SGsol[k2][3], true, vetass)
							break
						}
					}
				}
			}
		}
	}
}


//--------------------------------------------------------------------------------------------------------------------------------//
//Main function
def main(i, SecuritySmell, Microservice, relFrom, SGList, SGListName, MODEL, diagramManager, ssmod, SSassociation, asstype, microservices){
	def newPackage = IModelElementFactory.instance().createPackage()	//Create new package for a security smell
	newPackage.setName(SecuritySmell[i])		//Name the package with ne name of SS
	MODEL.addChild(newPackage)		//add it to the model				
	def secsmell
	for (n=0; n<ssmod.size(); n++){	//take the class related to the SS given as input from the SSKM
		if (ssmod[n].getName() == SecuritySmell[i])
			secsmell=ssmod[n]
	}
	def rels = secsmell.toToRelationshipEndArray()	//take all the children of this SS
	def refactoring = []
	for (l=0; l<rels.size(); l++){	//take the refactorings proposed to solve it by their stereotype in SSKM
		ref = rels[l].getOppositeEnd().getModelElement()
		if (ref.hasStereotype("Refactoring"))
			refactoring.add(ref)
	}
	def solution = []
	for (k=0; k< refactoring.size(); k++){	//take the refactoring solutions proposed in the SSKM to develope the selected refactoring
		sol = refactoring[k].toToRelationshipArray()
		for (n=0; n<sol.size(); n++)
			solution.add(sol[n].getFrom())
	}

	def SGsol =[]
	/*generate a structure such that for each solution has a rows of array 
		each one contains info about the SGs affected: [main , SG, Main SG, ster]
		- main : true/false if the SG is a main one or not
		- SG : softgoal affected
		- Main SG : Main SG of the affectefd SG (eventually itself)
		- ster : stereotype of the association between the refactoring solution and the SG in the SSKM
	*/
	for (g=0; g<solution.size(); g++){
		def supp=[]						
		arrival = solution[g].toToRelationshipEndArray()
		for (h=0; h< arrival.size(); h++){
			couple =[]
			el = arrival[h].getOppositeEnd().getModelElement()
			if (el.toStereotypeModelArray()[0].getName() contains "Main"){
				couple.add(true)
				couple.add(el.getName())
			}
			else{
				couple.add(false)
				couple.add(el.getParent().getName())
			}
			couple.add(el.getName())
			for (d=0; d<SSassociation.size(); d++){
				if (SSassociation[d].getTo() == solution[g] && SSassociation[d].getFrom() == el){
					couple.add(SSassociation[d].toStereotypeModelArray()[0].getName())
					break}
			}
			supp.add(couple)
		}
		SGsol.add(supp)
	}
	//Create the new diagram for each Microservice affected by the securitysmells
	def radices = []
	for (j1=0; j1< Microservice.size(); j1++){	//foreach microservice
		def Name = Microservice[j1]

		def diagPackage = IModelElementFactory.instance().createPackage()	//create a package with its name
		diagPackage.setName(Name)
		newPackage.addChild(diagPackage)	//add the package to the SS package
		
		def DD = diagramManager.createDiagram(IDiagramTypeConstants.DIAGRAM_TYPE_CLASS_DIAGRAM)	//create a new diagram
		
		DD.setName(Name)	//name it with ne name of the microservice
		
		diagramManager.openDiagram(DD)
		
		def NewSG = []	//List of elements in this new diagram
		def NewSGShape =[] 
		def REF = diagramManager.getActiveDiagram()	//get the new diagram
		
		diagPackage.addSubDiagram(REF)	//add the diagram to the package of the microservice

		def radix = []
		
		for (h=0; h<SGList.size(); h++){	//find in the SIG alla the SG of the selected microservice
			if (SGListName[h].contains(Name)){
				radix.add(h)	//construct the array of indices of this radices
				//generate the subgraphs starting from them in SIG and add them to the new diagram
				findSubGraph(h, relFrom, SGList, SGListName, REF, diagPackage, NewSG, NewSGShape, diagramManager, ssmod, asstype)
			}
		}
		diagramManager.layout(REF, diagramManager.LAYOUT_COMPACT)	//adjust the Layout	

		radices.add(radix)	//matrix of indices of radix (a row for each microservice)
		def micros = DFS(findMS(microservices,Name), microservices)	//find the subgraph of the influenced microservices (in the system model)
		for (n=0; n < solution.size(); n++){	//for each possible solution
		
			def solPackage = IModelElementFactory.instance().createPackage()//create a package named after the solution itself
			solPackage.setName(solution[n].getName())
			diagPackage.addChild(solPackage)	//add the package to the Microservice one
		
			def SolD = diagramManager.createDiagram(IDiagramTypeConstants.DIAGRAM_TYPE_CLASS_DIAGRAM)	//create a new (class) diagram
		
			SolD.setName(solution[n].getName())	//name it after the solution 
		
			diagramManager.openDiagram(SolD)
		
			def SolEl = []	//List of elements in this new diagram
			def SolElShape =[] 
			def SOL = diagramManager.getActiveDiagram()	//take the diagram
			vetass = []		//all the association in the new diagram
			solPackage.addSubDiagram(SOL)	//add the diagram to the just created packaga
			//generate the connected components of the subgraphs
			fun(micros, SGsol[n], radix, relFrom, SGList, SGListName, SOL, SolEl, SolElShape, solPackage, diagramManager, ssmod, asstype, vetass)	
			//add the solution node as a radix
			createSolNode(solution[n].getName(), Microservice[j1], SGsol[n], SolEl, SOL, SolElShape, solPackage, diagramManager, vetass)
			diagramManager.layout(SOL, diagramManager.LAYOUT_COMPACT)	//adjust the layout of the diagram
		}
		
	}
}

//---------------------------------------------------------------------------------------------------------------------------------------------//
//Main call to the main function (for each security smell)
for (i1=0; i1< SecuritySmells.size(); i1++)
	main(i1, SecuritySmells, Microservices, relFrom, SGList, SGListName, MODEL, diagramManager, ssmod, SSassociation, asstype, microservices)


return "All the subdiagrams are created!"